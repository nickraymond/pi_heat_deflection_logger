<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Realtime Dashboard</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
	body { font-family: Arial, sans-serif; margin: 20px; }
	canvas { width: 100%; max-height: 40vh; }
	.controls { margin: 16px 0; display: flex; gap: 8px; }
	.charts { display: flex; flex-direction: column; gap: 24px; }
	.status { margin-left: 12px; font-size: 0.9rem; color: #555; }

	/* Manual entry block */
	#manual-dial-entry { margin-bottom: 1rem; padding: 1rem; border: 1px solid #ddd; border-radius: 8px; }
	#manual-dial-entry h2 { margin-top: 0; }
	#manual-dial-entry .row { display: flex; align-items: center; gap: .5rem; margin: .5rem 0; }
	#manual-dial-entry input { max-width: 10rem; padding: .4rem .6rem; }
	#saveDialBtn { padding: .5rem .9rem; }
	#dialSaveMsg { margin-top: .5rem; }
	.hidden { display: none; }
	.error { border-color: #c00; }
  </style>
</head>
<body>
  <h1>Realtime Displacement & Temperature Dashboard</h1>

  <!-- Manual Dial Entry UI (ABOVE the charts) -->
  <section id="manual-dial-entry" class="card">
	<h2>Dial Indicator Manual Entry</h2>
	<form id="dialForm" onsubmit="return handleManualDialSave(event)">
	  <div class="row">
		<label for="dial1">Dial 1 (mm)</label>
		<input id="dial1" name="dial_1" type="number" step="0.01" inputmode="decimal" placeholder="e.g., 3.25" />
	  </div>
	  <div class="row">
		<label for="dial2">Dial 2 (mm)</label>
		<input id="dial2" name="dial_2" type="number" step="0.01" inputmode="decimal" placeholder="e.g., 3.30" />
	  </div>
	  <button id="saveDialBtn" type="submit">Save Measurement</button>
	</form>
	<div id="dialSaveMsg" class="hidden" role="status" aria-live="polite">✔ Saved!</div>
  </section>

  <div class="controls">
	<button id="startBtn">Start</button>
	<button id="stopBtn">Stop</button>
	<button id="exportBtn">Export CSV</button>
	<span class="status" id="statusText">Status: idle</span>
  </div>

  <div class="charts">
	<div>
	  <h3>Dial Indicators (mm)</h3>
	  <canvas id="dialChart"></canvas>
	</div>
	<div>
	  <h3>Temperature (°C)</h3>
	  <canvas id="tempChart"></canvas>
	</div>
  </div>

  <script>
	// --- Config ---
	const POLL_MS = 1000;          // poll /api/data every 1s
	const MAX_POINTS = 600;        // ~10 minutes at 1 Hz
	const PLOT_WHEN_IDLE = false;  // true = always render; false = only during logging

	// --- State ---
	let isLogging = false;

	// Track last ISO timestamp we plotted per sensor -> prevents flat lines
	const lastIsoBySensor = {};

	// Per-group state keyed by sensorId so we don’t collide on label
	const dialState = { labels: [], series: {} }; // series[sensorId] = { label, units, data: [] }
	const tempState = { labels: [], series: {} };

	// --- Charts ---
	const dialCtx = document.getElementById('dialChart').getContext('2d');
	const tempCtx = document.getElementById('tempChart').getContext('2d');

	function makeChart(ctx, yLabel) {
	  return new Chart(ctx, {
		type: 'line',
		data: { labels: [], datasets: [] },
		options: {
		  responsive: true,
		  animation: false,
		  interaction: { mode: 'nearest', intersect: false },
		  spanGaps: false, // show gaps instead of drawing a line across missing data
		  scales: {
			x: { title: { display: true, text: 'Local Time' } },
			y: { title: { display: true, text: yLabel } }
		  },
		  plugins: { legend: { display: true } }
		}
	  });
	}

	const dialChart = makeChart(dialCtx, 'Displacement (mm)');
	const tempChart = makeChart(tempCtx, 'Temperature (°C)');

	// --- Helpers ---
	function setStatusText() {
	  const el = document.getElementById('statusText');
	  el.textContent = `Status: ${isLogging ? 'logging…' : 'idle'}`;
	  el.style.color = isLogging ? '#0a0' : '#555';
	}

	// Adds a point for a single sensor, using one shared x-label per “tick”
	function pushPoint(group, chart, tsLabel, sensorId, sensorLabel, value, units) {
	  const labels = group.labels;
	  if (labels.length === 0 || labels[labels.length - 1] !== tsLabel) {
		labels.push(tsLabel);
		if (labels.length > MAX_POINTS) labels.shift();
	  }

	  // Ensure a series exists for this sensor
	  if (!group.series[sensorId]) {
		group.series[sensorId] = { label: sensorLabel || sensorId, units, data: [] };
		chart.data.datasets.push({
		  label: sensorLabel || sensorId,
		  data: [],
		  fill: false,
		  _sensorId: sensorId
		});
	  }

	  const s = group.series[sensorId];
	  s.data.push(value);
	  if (s.data.length > MAX_POINTS) s.data.shift();

	  // Rebuild chart arrays by sensorId
	  chart.data.labels = labels.slice();
	  chart.data.datasets.forEach(d => {
		const series = group.series[d._sensorId];
		d.data = series ? series.data.slice() : [];
	  });

	  chart.update();
	}

	// --- API ---
	async function getStatus() {
	  const r = await fetch('/api/status');
	  if (!r.ok) throw new Error('GET /api/status failed');
	  return r.json();
	}

	async function fetchData() {
	  const r = await fetch('/api/data');
	  if (!r.ok) throw new Error('GET /api/data failed');
	  return r.json();
	}

	async function startLogging() {
	  try {
		const r = await fetch('/api/start', { method: 'POST' });
		if (r.ok) {
		  isLogging = true;
		  if (!PLOT_WHEN_IDLE) {
			// Reset plotting window on new run (optional)
			Object.keys(lastIsoBySensor).forEach(k => delete lastIsoBySensor[k]);
			dialState.labels = []; dialState.series = {};
			tempState.labels = []; tempState.series = {};
			dialChart.data.labels = []; dialChart.data.datasets = [];
			tempChart.data.labels = []; tempChart.data.datasets = [];
			dialChart.update(); tempChart.update();
		  }
		}
	  } catch (e) { console.error(e); }
	  setStatusText();
	}

	async function stopLogging() {
	  try {
		const r = await fetch('/api/stop', { method: 'POST' });
		if (r.ok) isLogging = false;
	  } catch (e) { console.error(e); }
	  setStatusText();
	}

	async function exportLog() {
	  const res = await fetch('/api/export');
	  if (!res.ok) { alert('No log file found.'); return; }
	  const blob = await res.blob();
	  const url = window.URL.createObjectURL(blob);
	  const a = document.createElement('a');
	  a.href = url;
	  const disp = res.headers.get('Content-Disposition') || '';
	  const m = disp.match(/filename="?([^"]+)"?/);
	  a.download = m ? m[1] : 'log.csv';
	  a.click();
	  URL.revokeObjectURL(url);
	}

	// --- Polling ---
	async function pollStatus() {
	  try {
		const s = await getStatus();
		isLogging = !!s.logging;
		setStatusText();
	  } catch (e) {
		console.error(e);
	  }
	}

	async function tick() {
	  try {
		const data = await fetchData();

		// Only plot during logging unless you set PLOT_WHEN_IDLE=true
		if (!isLogging && !PLOT_WHEN_IDLE) return;

		// For each sensor, only add a point if timestamp changed
		// Also use the sensor's timestamp as the x-axis label so points align to save time
		for (const [sensorId, s] of Object.entries(data)) {
		  const iso = s.timestamp;               // ISO string from backend
		  const lastIso = lastIsoBySensor[sensorId];

		  if (lastIso === iso) continue;         // nothing new for this sensor

		  lastIsoBySensor[sensorId] = iso;       // mark as plotted
		  const tsLabel = new Date(iso).toLocaleTimeString();

		  const isTemp = (s.sensor_type || '').toLowerCase() === 'temperature';
		  const group = isTemp ? tempState : dialState;
		  const chart = isTemp ? tempChart : dialChart;

		  pushPoint(group, chart, tsLabel, sensorId, s.sensor_label, s.sensor_value, s.sensor_units);
		}
	  } catch (e) {
		console.error(e);
	  }
	}

	// Called after a successful manual save to redraw immediately
	window.reloadDialPlot = function () {
	  tick(); // draw immediately instead of waiting up to 1s
	};

	// --- Wire up buttons ---
	document.getElementById('startBtn').addEventListener('click', startLogging);
	document.getElementById('stopBtn').addEventListener('click', stopLogging);
	document.getElementById('exportBtn').addEventListener('click', exportLog);

	// --- Kickoff ---
	setStatusText();
	pollStatus();
	setInterval(pollStatus, 2000);
	setInterval(tick, POLL_MS);
  </script>

  <!-- Manual entry logic (save + confirmation + chart refresh) -->
  <script src="/static/js/manual_dial.js"></script>
</body>
</html>
